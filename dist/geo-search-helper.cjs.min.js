/**
 * Short version for minified scripts:
 *
 * The MIT License (MIT)
 * Copyright (c) 2022 Espen Klem
 *
 * Full license text + Third party licenses found in ./LICENSES.txt
 */

"use strict";function t(t,n){return t.map((t=>n.reduce(((t,n)=>t[n]),t)))}function n(t){return t.sort(((t,n)=>t-n)),t.splice(1,t.length-2),t}function o(t,n,o,r=6371){const e=Math.PI,l=a(t.lat),u=a(t.lon),h=a(Number(o)),c=n/r,i=c*Math.cos(h);let M=l+i;Math.abs(M)>e/2&&(M=M>0?e-M:-e-M);const f=Math.log(Math.tan(M/2+e/4)/Math.tan(l/2+e/4)),p=Math.abs(f)>1e-11?i/f:Math.cos(l),d=u+c*Math.sin(h)/p;return{lat:s(M),lon:s(d)}}function a(t){return t*(Math.PI/180)}function s(t){return 180*t/Math.PI}Object.defineProperty(exports,"__esModule",{value:!0}),exports.getDistanceFromLatLonInKm=function(t,n){const o=a(n.lat-t.lat),s=a(n.lon-t.lon),r=Math.sin(o/2)*Math.sin(o/2)+Math.cos(a(t.lat))*Math.cos(a(n.lat))*Math.sin(s/2)*Math.sin(s/2);return 6371*(2*Math.atan2(Math.sqrt(r),Math.sqrt(1-r)))},exports.mapBoundsPoints=function(o,a,s){if(o.length<=1)throw new Error("mapBoundsPoints: Array to short to find boundaries. Needs two or more points.");const r=t(o,a);n(r);const e=t(o,s);return n(e),{sw:{lat:r[0],lon:e[0]},ne:{lat:r[1],lon:e[1]}}},exports.mapBoundsPosKm=function(t,n){const a=o(t,n,0),s=o(t,n,90),r=o(t,n,180),e=o(t,n,270);return{sw:{lat:r.lat,lon:e.lon},ne:{lat:a.lat,lon:s.lon}}};
