/**
 * Short version for minified scripts:
 *
 * The MIT License (MIT)
 * Copyright (c) 2022 Espen Klem
 *
 * Full license text + Third party licenses found in ./LICENSES.txt
 */

!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((t="undefined"!=typeof globalThis?globalThis:t||self).gsh={})}(this,(function(t){"use strict";function n(t,n){return t.map((t=>n.reduce(((t,n)=>t[n]),t)))}function o(t){return t.sort(((t,n)=>t-n)),t.splice(1,t.length-2),t}function e(t,n,o,e=6371){const r=Math.PI,l=a(t.lat),i=a(t.lon),u=a(Number(o)),h=n/e,c=h*Math.cos(u);let f=l+c;Math.abs(f)>r/2&&(f=f>0?r-f:-r-f);const M=Math.log(Math.tan(f/2+r/4)/Math.tan(l/2+r/4)),d=Math.abs(M)>1e-11?c/M:Math.cos(l),p=i+h*Math.sin(u)/d;return{lat:s(f),lon:s(p)}}function a(t){return t*(Math.PI/180)}function s(t){return 180*t/Math.PI}t.getDistanceFromLatLonInKm=function(t,n){const o=a(n.lat-t.lat),e=a(n.lon-t.lon),s=Math.sin(o/2)*Math.sin(o/2)+Math.cos(a(t.lat))*Math.cos(a(n.lat))*Math.sin(e/2)*Math.sin(e/2);return 6371*(2*Math.atan2(Math.sqrt(s),Math.sqrt(1-s)))},t.mapBoundsPoints=function(t,e,a){if(t.length<=1)throw new Error("mapBoundsPoints: Array to short to find boundaries. Needs two or more points.");const s=n(t,e);o(s);const r=n(t,a);return o(r),{sw:{lat:s[0],lon:r[0]},ne:{lat:s[1],lon:r[1]}}},t.mapBoundsPosKm=function(t,n){const o=e(t,n,0),a=e(t,n,90),s=e(t,n,180),r=e(t,n,270);return{sw:{lat:s.lat,lon:r.lon},ne:{lat:o.lat,lon:a.lon}}},Object.defineProperty(t,"__esModule",{value:!0})}));
